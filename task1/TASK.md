# Окружение: 
* ОС - `6.1.71-1-MANJARO`.
* Процессор - `11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz`.
* Размер `L1d` - `384 Kib`


# Метод конечных разностей: 
Это один из наиболее распространенных подходов численного решения
дифференциальных уравнений. Метод конечных разностей может быть спользован для численного решения задачи Дирихле (*для уравнения Пуассона*). 


>**Задача Пуассона оределяется следующим образом:**
>
>(Для простоты: $`f:R^2 -> R`$)
$`\begin{cases}
\dfrac{\delta^2u}{\delta x^2} + \dfrac{\delta^2u}{\delta y^2} = f(x, y), & \quad \text{$(x, y) \in D $}\\ 
u(x, y)=g(x,y)  & \quad \text{$(x, y) \in D^0 $}
\end{cases}`$
> * $`u := u(x, y)`$ - функция, которую надо найти
> * $`D`$ - область определения
> * $`D^0`$ - граница области $`D`$
> * $`f`$ и $`g`$ - функции, заданные при постановке задачи


>**Метод конечных разностей:**
>
>(Для простоты: $`D \subset [0,1]\times[0,1]`$)
>$`
D := \{(x_i, y_j):x_i=ih,y_j=jh, 0\leq i, j \leq N+1, h=1/(N+1)\}
\\
u_{ij} = 0.25*(u_{i-1,j} + u_{i+1, j} + u_{i,j-1} + u_{i,j+1} - h^2*f_{ij})
`$
> * функция $u$ во всех $`ij`$-ых точках приближается до тех пор (*метод итеративный*) пока 
>$`
\max_{0\leq i, j \leq N+1}(u_{ij}^k - u_{ij}^{k-1}) \leq \epsilon
`$
> * $`\epsilon`$ - задается
> * $`^k`$ - $`k`$-ая итерация

# Реализация: 
* Параллельная реализация алгоритма, основанного на этом методе, находится в файле `src/method.с`.
* Параллельные вычисления организованы с использованием библиотеки `OpenMP`.
* Поддерживается интерполяция функций:
  * $`D \subset [0,1]\times[0,1]`$
  * $`f:D -> R`$
* Инструменты для анализа эффективности алгоритма:
  * `scripts\generate_results.py` - позволяет визуализировать результаты интерполяции и вычислить отклонение от искомой функции
  * `scripts\summarize_results.py` - сохраняет результаты вычислений в единой таблице


# Тестирование
> Все результаты получены на выборке из $20$ запусков.

## Корректность
### $1000*x^3 + 2000*y^3$
#### Были проведены замеры отклонения полученного значения функции $u$ от эталонного значения. Использовался максимум абсолютной ошибки.

* $\epsilon = 0.1$
* $bs = 64$
* $threads = 8$

Результаты представлены в таблице:

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>N</th>
      <th>max_error</th>
      <th>ci_interval</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>10.0</td>
      <td>0.7</td>
      <td>0.0</td>
    </tr>
    <tr>
      <td>50.0</td>
      <td>24.22414</td>
      <td>0.00003</td>
    </tr>
    <tr>
      <td>100.0</td>
      <td>95.7</td>
      <td>0.0</td>
    </tr>
    <tr>
      <td>500.0</td>
      <td>558.7</td>
      <td>0.15</td>
    </tr>
    <tr>
      <td>1000.0</td>
      <td>1390.045496</td>
      <td>0.36</td>
    </tr>
  </tbody>
</table>

Из таблицы видно, что с увеличением N при фиксированном $\epsilon$ точность интерполяции существенно снижается. 



<details><summary>Расширенная версия таблицы </summary>

   <table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>N</th>
      <th>eps</th>
      <th>max_err</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>10</td>
      <td>0.001</td>
      <td>0.01</td>
    </tr>
    <tr>
      <th>1</th>
      <td>10</td>
      <td>0.010</td>
      <td>0.07</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10</td>
      <td>0.100</td>
      <td>0.68</td>
    </tr>
    <tr>
      <th>3</th>
      <td>50</td>
      <td>0.001</td>
      <td>0.24</td>
    </tr>
    <tr>
      <th>4</th>
      <td>50</td>
      <td>0.010</td>
      <td>2.42</td>
    </tr>
    <tr>
      <th>5</th>
      <td>50</td>
      <td>0.100</td>
      <td>24.22</td>
    </tr>
    <tr>
      <th>6</th>
      <td>100</td>
      <td>0.001</td>
      <td>0.99</td>
    </tr>
    <tr>
      <th>7</th>
      <td>100</td>
      <td>0.010</td>
      <td>9.91</td>
    </tr>
    <tr>
      <th>8</th>
      <td>100</td>
      <td>0.100</td>
      <td>95.68</td>
    </tr>
    <tr>
      <th>9</th>
      <td>500</td>
      <td>0.001</td>
      <td>18.05</td>
    </tr>
    <tr>
      <th>10</th>
      <td>500</td>
      <td>0.010</td>
      <td>122.97</td>
    </tr>
    <tr>
      <th>11</th>
      <td>500</td>
      <td>0.100</td>
      <td>569.74</td>
    </tr>
    <tr>
      <th>12</th>
      <td>1000</td>
      <td>0.001</td>
      <td>98.50</td>
    </tr>
    <tr>
      <th>13</th>
      <td>1000</td>
      <td>0.010</td>
      <td>555.43</td>
    </tr>
    <tr>
      <th>14</th>
      <td>1000</td>
      <td>0.100</td>
      <td>1389.68</td>
    </tr>
  </tbody>
</table>

</details>



> Размер сетки $1000$; $\epsilon = 0.5$:
> 
> <img src="img/05.png" width="500">
>
> Размер сетки $1000$; $\epsilon = 0.001$:
> 
> <img src="img/00001.png" width="500">

## Эффективность

> Время ($t$) вычисляется в секундах.
---

#### Были проведены эксперименты, которые показывают, какими значениями лучше всего инициализировать $u_{ij}^0$.
> * Здесь очевидным фактом является то, что чем ближе инициализируемые значения будут к значениям функции, тем время
> сходимости будет ниже. 
> 
> * Однако в условиях, когда известны только граничные значения,
> выгоднее всего инициализировать расчетную сетку средним арефметическим этих граничных значений. 

**Результаты представлены в таблице:**
* $N = 500$
* $\epsilon = 0.1$
* $bs = 64$
* $threads = 8$

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>func</th>
      <th>iters</th>
      <th>t</th>
      <th>ci_interval</th>
      <th>mes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1000*x^3+2000*y^3</td>
      <td>4995</td>
      <td>1.44</td>
      <td>0.02</td>
      <td>Заполнять D\D^0 average(u(D^0))</td>
    </tr>
    <tr>
      <td>1000*x^3+2000*y^3</td>
      <td>5874</td>
      <td>1.672</td>
      <td>0.011</td>
      <td>Заполнять D\D^0 рандомными числами из [0; average(u(D^0))]</td>
    </tr>
    <tr>
      <td>1000*x^3+2000*y^3</td>
      <td>6808</td>
      <td>2.00</td>
      <td>0.03</td>
      <td>Заполнить D\D^0 нулями</td>
    </tr>
    <tr>
      <td>1000*x^3+2000*y^3</td>
      <td>11286</td>
      <td>3.18</td>
      <td>0.03</td>
      <td>Заполнять D\D^0 max(u(D^0))</td>
    </tr>
    <tr>
      <td>1000*x^3+2000*y^3</td>
      <td>24341</td>
      <td>6.76</td>
      <td>0.12</td>
      <td>Заполнять D\D^0 рандомными числами из [0; const=10000]</td>
    </tr>
    <tr>
      <td>sin(x)</td>
      <td>5</td>
      <td>0.00459</td>
      <td>0.00015</td>
      <td>Заполнять D\D^0 рандомными числами из [0; average(u(D^0))]</td>
    </tr>
    <tr>
      <td>sin(x)</td>
      <td>5</td>
      <td>0.00460</td>
      <td>0.00015</td>
      <td>Заполнить D\D^0 нулями</td>
    </tr>
    <tr>
      <td>sin(x)</td>
      <td>5</td>
      <td>0.00463</td>
      <td>0.00017</td>
      <td>Заполнять D\D^0 max(u(D^0))</td>
    </tr>
    <tr>
      <td>sin(x)</td>
      <td>5</td>
      <td>0.0047</td>
      <td>0.0003</td>
      <td>Заполнять D\D^0 average(u(D^0))</td>
    </tr>
    <tr>
      <td>sin(x)</td>
      <td>27686</td>
      <td>8.07</td>
      <td>0.12</td>
      <td>Заполнять D\D^0 рандомными числами из [0; const=10000]</td>
    </tr>
  </tbody>
</table>

---
#### Стоит заметить, что чем больше будет разница между значениями функции, тем дольше она будет сходиться (*при фиксированном размере сетки и $\epsilon$*):

* $N = 500$
* $\epsilon = 0.1$
* $bs = 64$
* $threads = 12$

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>func</th>
      <th>iters</th>
      <th>t</th>
      <th>ci_interval</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1000*x^3+2000*y^3</td>
      <td>4975</td>
      <td>1.522</td>
      <td>0.015</td>
    </tr>
    <tr>
      <td>x^3+y^3</td>
      <td>9</td>
      <td>0.0055</td>
      <td>0.0009</td>
    </tr>
    <tr>
      <td>2000*x+100*y</td>
      <td>5005</td>
      <td>1.541</td>
      <td>0.015</td>
    </tr>
    <tr>
      <td>x+y</td>
      <td>10</td>
      <td>0.0051</td>
      <td>0.0002</td>
    </tr>
  </tbody>
</table>

---

#### Сравнение скорости сходимости $1000*x^3 + 2000*y^3$ при разном количестве потоков с фиксированным $bs$:
* $bs = 64$
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th colspan="3"></th>
      <th colspan="7" align="center">threads</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th colspan="3" ></th>
      <td>1</td>
      <td>4</td>
      <td>8</td>
      <td>12</td>
    </tr>
    <tr>
      <th>1</th>
      <td>N</td>
      <td>eps</td>
      <th colspan="7" align="center">t</th>
    </tr>
    <tr>
      <th>2</th>
      <td>10</td>
      <td>0.01</td>
      <td>0.00002</td>
      <td>0.00007</td>
      <td>0.00007</td>
      <td>0.00010</td>
    </tr>
    <tr>
      <th>3</th>
      <td>50</td>
      <td>0.01</td>
      <td>0.011</td>
      <td>0.013</td>
      <td>0.013</td>
      <td>0.021</td>
    </tr>
    <tr>
      <th>4</th>
      <td>100</td>
      <td>0.01</td>
      <td>0.16</td>
      <td>0.12</td>
      <td>0.13</td>
      <td>0.16</td>
    </tr>
    <tr>
      <th>5</th>
      <td>500</td>
      <td>0.01</td>
      <td>18.26</td>
      <td>7.22</td>
      <td>5.78</td>
      <td>6.71</td>
    </tr>
    <tr>
      <th>6</th>
      <td>1000</td>
      <td>0.01</td>
      <td>174.1</td>
      <td>57.2</td>
      <td>39.9</td>
      <td>37.9</td>
    </tr>
  </tbody>
</table>

Можно сделать вывод, что параллельный алгоритм эффективнее последовательного 
только в случае, когда $bs$ превышает размер сетки хотя бы в 8-10 раз.
